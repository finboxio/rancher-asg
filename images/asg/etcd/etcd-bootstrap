#! /bin/bash

SERF_CONTAINER=${SERF_CONTAINER:-serf}
SERF_WAIT=${SERF_WAIT:-60}
ETCD_DATA_DIR=${ETCD_DATA_DIR:-/etc/etcd/data}
ETCD_CLIENT_PORT=${ETCD_CLIENT_PORT:-2379}
ETCD_SERVER_PORT=${ETCD_SERVER_PORT:-2380}
ETCD_CLIENT_SCHEME=${ETCD_CLIENT_SCHEME:-http}
ETCD_PEER_SCHEME=${ETCD_PEER_SCHEME:-http}
ETCD_PROXY=${ETCD_PROXY:-off}
ETCD_CURLOPTS="-k --max-time 2 $ETCD_CURLOPTS"

retry_times=${RETRY_TIMES:-10}
wait_time=3
add_ok=201
already_added=409
delete_ok=204
delete_gone=410

# If serf is not running, just exit because we won't get a list of hosts
if ! (docker inspect $SERF_CONTAINER &> /dev/null); then
  echo "Cannot bootstrap because serf is not running. Exiting in 10s"
  sleep 10
  exit 1
fi

# If serf hasn't been up long enough, exit
current=$(date +%s)
started=$(date -d "$(docker inspect $SERF_CONTAINER \
  | jq -r .[0].State.StartedAt \
  | cut -d . -f 1 \
  | awk '{print $1}' \
  | tr 'T' ' ')" +%s)
uptime=$((current - started))
if [[ "$uptime" -lt "$SERF_WAIT" ]]; then
  echo "Cannot bootstrap because serf hasn't been up long enough. Exiting in 10s"
  sleep 10
  exit 1
fi

instance_name=$(docker exec $SERF_CONTAINER serf info -format json | jq -r .agent.name)
serf_members=$(docker exec $SERF_CONTAINER serf members -format json | jq '.members[] | select(.status == "alive")')
instance_ip=$(echo "$serf_members" \
  | jq -r "select(.name == \"$instance_name\") | .addr" \
  | cut -d: -f1)

etcd_peer_urls=$(echo "$serf_members" \
  | jq -r ".addr" \
  | cut -d: -f1 \
  | xargs -I{} echo "$ETCD_CLIENT_SCHEME://{}:$ETCD_CLIENT_PORT")

echo "etcd_peer_urls="$etcd_peer_urls
if [[ ! $etcd_peer_urls ]]; then
  echo "Cannot bootstrap because no peer urls are available. Exiting in 10s"
  sleep 10
  exit 1
fi

etcd_existing_peer_urls=
etcd_existing_peer_names=
etcd_good_member_url=

for url in $etcd_peer_urls; do
  case "$url" in
    # If we're in proxy mode this is an error, but unlikely to happen?
    *$instance_ip*) continue;;
  esac

  etcd_members=$(curl $ETCD_CURLOPTS -f -s $url/v2/members)

  if [[ $? == 0 && $etcd_members ]]; then
    etcd_good_member_url="$url"
    echo "etcd_members=$etcd_members"
    etcd_existing_peer_urls=$(echo "$etcd_members" | jq --raw-output .[][].peerURLs[0])
    etcd_existing_peer_names=$(echo "$etcd_members" | jq --raw-output .[][].name)
    break
  fi
done

echo "etcd_good_member_url=$etcd_good_member_url"
echo "etcd_existing_peer_urls=$etcd_existing_peer_urls"
echo "etcd_existing_peer_names=$etcd_existing_peer_names"

export ETCD_NAME=$instance_name
export ETCD_ADVERTISE_CLIENT_URLS="$ETCD_CLIENT_SCHEME://$instance_ip:$ETCD_CLIENT_PORT"
export ETCD_LISTEN_CLIENT_URLS="$ETCD_CLIENT_SCHEME://$instance_ip:$ETCD_CLIENT_PORT,http://localhost:2379"
export ETCD_LISTEN_PEER_URLS="$ETCD_CLIENT_SCHEME://$instance_ip:$ETCD_SERVER_PORT"
export ETCD_PROXY=$ETCD_PROXY
if [[ "$ETCD_CLIENT_SCHEME" == "https" ]]; then export ETCD_AUTO_TLS=1; fi
if [[ "$ETCD_PEER_SCHEME" == "https" ]]; then export ETCD_PEER_AUTO_TLS=1; fi

# Try to join an existing cluster under either of two circumstances:
#
#   1. I am not listed as a member of the cluster.
#      I need to add myself before joining.
#
#   2. I am listed as a member and have previously been bootstrapped.
#      I need to remove myself and re-add before joining.
#
# If neither of these conditions apply, or if no valid existing cluster
# appears to be reachable, we'll start etcd in bootstrap mode

if [[ "$etcd_existing_peer_urls" != "" && ("$etcd_existing_peer_names" != *"$instance_name"* || -e $ETCD_DATA_DIR/bootstrapped) ]]; then
  echo "joining existing cluster"

  # eject bad members from cluster
  etcd_peer_urls=$(echo "$etcd_peer_urls" \
    | grep -v $ETCD_ADVERTISE_CLIENT_URLS)

  peer_regexp=$(echo "$etcd_peer_urls" \
    | sed 's/^.*'$ETCD_PEER_SCHEME'\{0,1\}:\/\/\([0-9.]*\):[0-9]*.*$/contains(\\"\/\/\1:\\")/' \
    | xargs \
    | sed 's/  */ or /g')

  if [[ ! $peer_regexp ]]; then
    echo "failed to create peer regular expression"
    exit 1
  fi

  bad_peer=$(echo "$etcd_members" \
    | jq --raw-output ".[] | map(select(.peerURLs[] | $peer_regexp | not )) | .[].id")

  echo "peer_regexp=$peer_regexp"
  echo "bad_peer=$bad_peer"

  if [[ $bad_peer ]]; then
    for bp in $bad_peer; do
      status=0
      retry=1
      name=$(echo "$etcd_members" | jq --raw-output ".[][] | select(.id == \"$bp\") | .name")
      until [[ $status = $delete_ok || $status =  $delete_gone || $retry = $retry_times ]]; do
        status=$(curl $ETCD_CURLOPTS -f -s -w %{http_code} "$etcd_good_member_url/v2/members/$bp" -XDELETE)
        echo "removing bad peer $bp, retry $((retry++)), return code $status."
        sleep $wait_time
      done
      if [[ $status != $delete_ok && $status != $delete_gone ]]; then
        echo "ERROR: failed to remove bad peer: $bad_peer, return code $status."
        exit 1
      else
        echo "removed bad peer: $bad_peer, return code $status."
      fi
    done
  fi

  etcd_initial_cluster=$(curl $ETCD_CURLOPTS -s -f "$etcd_good_member_url/v2/members" \
    | jq --raw-output '.[] | map(.name + "=" + .peerURLs[0]) | .[]' \
    | xargs \
    | sed 's/  */,/g')
  etcd_initial_cluster=$(echo "$etcd_initial_cluster,$instance_name=${ETCD_PEER_SCHEME}://${instance_ip}:$ETCD_SERVER_PORT")

  echo "etcd_initial_cluster=$etcd_initial_cluster"
  if [[ ! $etcd_initial_cluster ]]; then
    echo "docker command to get etcd peers failed"
    exit 1
  fi

  # join the existing cluster
  status=0
  retry=1
  until [[ $status = $add_ok || $status = $already_added || $retry = $retry_times ]]; do
    status=$(curl $ETCD_CURLOPTS -f -s -w %{http_code} -o /dev/null -XPOST "$etcd_good_member_url/v2/members" -H "Content-Type: application/json" -d \
    '{
      "peerURLs": ["'$ETCD_PEER_SCHEME'://'$instance_ip':'$ETCD_SERVER_PORT'"],
      "name": "'$instance_name'"
    }')
    echo "adding instance ID $instance_name with IP $instance_ip, retry $((retry++)), return code $status."
    sleep $wait_time
  done
  if [[ $status != $add_ok && $status != $already_added ]]; then
    echo "unable to add $instance_ip to the cluster: return code $status."
    exit 9
  else
    echo "added $instance_ip to existing cluster, return code $status"
  fi

  rm -rf $ETCD_DATA_DIR/*
  export ETCD_INITIAL_CLUSTER_STATE=existing
  export ETCD_INITIAL_CLUSTER="$etcd_initial_cluster"
  export ETCD_INITIAL_ADVERTISE_PEER_URLS="$ETCD_PEER_SCHEME://$instance_ip:$ETCD_SERVER_PORT"
elif [[ "$etcd_existing_peer_urls" != "" || ! -e $ETCD_DATA_DIR/bootstrapped ]]; then
  echo "bootstrapping new cluster"

  etcd_initial_cluster=$(echo "$serf_members" \
      | jq -r ".name + \"=$ETCD_PEER_SCHEME://\" + .addr" \
      | awk -F ":" "{ print \$1\":\"\$2\":$ETCD_SERVER_PORT\" }" \
      | xargs \
      | tr ' ' ',')

  echo "etcd_initial_cluster=$etcd_initial_cluster"
  if [[ ! $etcd_initial_cluster ]]; then
    echo "unable to get peers from auto scaling group"
    exit 10
  fi

  rm -rf $ETCD_DATA_DIR/*
  export ETCD_INITIAL_CLUSTER_STATE=new
  export ETCD_INITIAL_CLUSTER="$etcd_initial_cluster"
  export ETCD_INITIAL_ADVERTISE_PEER_URLS="$ETCD_PEER_SCHEME://$instance_ip:$ETCD_SERVER_PORT"
else
  # This node has previously been bootstrapped, but cannot find any peers.
  # We need to restore from backup and create a new cluster
  etcd --force-new-cluster &
  pid=$!
  new_member_id=
  while [[ "$new_member_id" == "" ]]; do
    sleep 2
    new_member_id=$(curl -s http://localhost:2379/v2/members | jq -r .members[0].id)
  done
  curl -s -XPUT http://localhost:2379/v2/members/$new_member_id \
    -H "Content-Type: application/json" \
    -d '{"peerURLs":["'$ETCD_PEER_SCHEME'://'$instance_ip':'$ETCD_SERVER_PORT'"]}'
  kill $pid
fi

mkdir -p $ETCD_DATA_DIR || true
echo $etcd_initial_cluster > $ETCD_DATA_DIR/bootstrapped

etcd $@
